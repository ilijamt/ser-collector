<?php

namespace CSR\Engine;

use GuzzleHttp\Client;
use GuzzleHttp\Pool;
use GuzzleHttp\Psr7\Request;

/**
 * Engine wrapper that handles all the engines together
 */
class Wrapper
{

    /**
     * Client that is used for handling all the requests generated by {@link #generateRequests}
     *
     * @var Client
     */
    protected $client;

    /**
     * A list of all the engines in our system, loaded by {@link #loadEngines}
     *
     * @var array
     */
    protected $engines = array();

    /**
     * Wrapper constructor.
     */
    public function __construct()
    {
        $this->client = new Client(['cookies' => true]);
        $this->loadEngines();
    }

    /**
     * Load all the engines that we have in our system
     */
    protected function loadEngines()
    {
        foreach (glob(__DIR__ . DIRECTORY_SEPARATOR . "Engines" . DIRECTORY_SEPARATOR . "*.php") as $engine) {
            $name = basename($engine, ".php");
            $class = "\\CSR\\Engine\\Engines\\$name";
            $this->engines[$name] = new $class();
        }
    }

    /**
     * Process all the engines that we have in our system and format the response to be processed by {@link Results}
     *
     * @param $query
     * @return array
     */
    public function process($query)
    {

        $responses = array();

        $pool = new Pool($this->client, $this->generateRequests($query), [
            "concurrency" => 10,
            "fulfilled" => function ($response, $engineName) use (&$responses) {
                $responses[$engineName] = $response->getBody();
            },
            "rejected" => function ($reason, $index) {
                // this is delivered each failed request
            },
        ]);

        $promise = $pool->promise();
        $promise->wait();

        // now process all the responses and map them onto the search results
        foreach ($responses as $engineName => $response) {
            $responses[$engineName] = $this->engines[$engineName]->process($response);
        }

        return $responses;

    }

    /**
     * Generate all the requests so we can do all of them concurently
     *
     * @param $query
     * @return \Generator
     */
    protected function generateRequests($query)
    {
        foreach ($this->engines as $name => $engine) {
            yield  $name => $this->engines[$name]->getSearchRequest($query);
        }
    }

}